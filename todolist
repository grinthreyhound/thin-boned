//2 valid approaches: conditional poisson regression or inserting the matching set into poisson as ranom effect variable.
//though likely that accounting for matching will make little difference so can do sensitivity analysis to that effect
//Using own date confirmed as the right thing to do.  
//NB data definitely overdispersed, so negative binomial (xtpoisson) appropriate. 

//get the data
//start with a small section
set memory 1g
cd "H:\JOE\THIN"
use in 1/1000 using consultation15_ss2_CC.dta
// case is 1, control is 2, recode this
recode case_control (2=0)

//create new index date: where it is the last contact in the record:

by id, sort: egen lasttime = max(eventdate)
format lasttime %td

//create a new entry date
gen enter = lasttime-456

//and new scaling for events: time before lasttime
gen studyeventdate= eventdate - lasttime
replace studyeventdate = sqrt(studyeventdate^2)

//need a variable for any failure:
generate failure=1
//First create a list numbers:
*generate order = _n
//create a label y for each nth event that each child has
*by id (order), sort: generate y = _n 
//generate a variable that is the maximum of y (i.e. the number of consultations per person)
*egen z = max(y), by(id)
//tabulate this with column %
*tab z case, col

//need to compare baseline contacts between cases and controls: 
//stset the data to indicate is survival time data with multiple lines per person (specify id)
//Need to specify exit or else it terminates after first failure

//For the whole dataset only: check duration of time in study with events occuring:
*by id, sort: egen firstdate = min(eventdate)
*gen duration = lasttime - firstdate
*sum duration

//to use Xt poisson need to xtset the data: delare it to be panel data: xtset panelvar timevar
//xtsetting is a new command, //Panel data assumes there have been observations I think, so STset/stsplit first
//cant use string id so need to group this  NB: if want to keep labels could instead use : encode id,gen(numid) 
egen numid =group(id)

*preserve
stset eventdate, id(id) fail(failure) exit(time .) origin(enter) scale(1)
stsplit earlylate, at(444(3)456) after(enter) 
stset, clear
//need a matching variable: strings not allowed, so number them: (can't do this before stsetting as doesn't expand clusterid)
sort id
by id: generate mgroup = id if case_control ==1
replace mgroup = case_id if case_control ==0
egen clusterid = group(mgroup)


//now need to sort out multiples: casued by some presenting >1 time in stplit period (including >1 per day for some)
//generate dup to count duplicates
sort numid earlylate
quietly by numid earlylate: gen dup = cond(_N==1,0,_n)
//get the number of events in each duplicated time period
by numid earlylate: egen events = max(dup)
//drop the duplicates but keep the number of events
drop if dup<events
//Make failure missing values ==0
recode failure(.=0)
//now redefine the failures to be the number of events: failure is now the number of events in the time period
replace failure = events if events>failure

//drop the last events - the ones selected upon, but only if there are no multiples in that time period:
replace failure=failure-1 if lasttime==eventdate & failure!=0
//now we have panel data with time from event in earlylate and number of events in each time period in failure
//Need to turn earlylate into an ordinal thingy
recode earlylate (0=1) (444=2) (447=3) (450=4) (453=5)
*duplicates report earlylate numid
xtset clusterid
*xtpoisson failure case_control, irr 

preserve
keep if earlylate==1
xtpoisson failure case_control, irr
restore
//
preserve
keep if earlylate==2
xtpoisson failure case_control, irr
restore 
//
preserve
keep if earlylate==3
xtpoisson failure case_control, irr
restore
//
preserve
keep if earlylate==4
xtpoisson failure case_control, irr
restore
//
preserve
keep if earlylate==5
xtpoisson failure case_control, irr
restore

